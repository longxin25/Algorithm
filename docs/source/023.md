### 队列

  * 队列也是一种操作受限的线性表，不同于栈，队列可以允许在两端操作，但是其中一端只能用来添加元素（队尾），另外一端只能用来移除元素（队首），过程类似于现实中的排队。

---

### 代码实现（数组）

    class Queue:
    
        def __init__(self, capacity) -> None:
            self.__data = []
            self.__capacity = capacity
            self.__head = 0
            self.__tail = 0

        @property
        def data(self):
            return self.__data

        @data.setter
        def data(self, data):
            self.__data = data

        @property
        def head(self):
            return self.__head

        @head.setter
        def head(self, head):
            self.__head = head

        @property
        def tail(self):
            return self.__tail

        @tail.setter
        def tail(self, tail):
            self.__tail = tail

        def enqueue(self, value):
            if self.tail == self.__capacity:
                if self.head == 0:
                    return
                else:
                    # 数据搬移
                    for i in range(0, self.tail - self.head):
                        self.data[i] = self.data[i + self.head]
                    self.tail = self.tail - self.head
                    self.head = 0

            self.data[self.tail] = value
            self.tail += 1

        def dequeue(self):
            if self.head == self.tail:
                return
            value = self.data[self.head]
            del self.data[self.head]
            self.head += 1
            return value
            
---

### 代码实现（链表）

    class Node:

        def __init__(self, data=None, next=None) -> None:
            self.__data = data
            self.__next = next

        @property
        def data(self):
            return self.__data

        @data.setter
        def data(self, data):
            self.__data = data

        @property
        def next(self):
            return self.__next

        @next.setter
        def next(self, next):
            self.__next = next


     class Queue:

        def __init__(self) -> None:
            self.__head = Node()
            self.__tail = Node()

        @property
        def head(self):
            return self.__head

        @head.setter
        def head(self, head):
            self.__head = head

        @property
        def tail(self):
            return self.__tail

        @tail.setter
        def tail(self, tail):
            self.__tail = tail

        def enqueue(self, node):
            if self.tail.next == None:
                self.head.next = node
                self.tail.next = node
            else:
                self.tail.next.next = node
                self.tail.next = node

        def dequeue(self):
            if self.tail.next == None:
                return
            else:
                value = self.head.next.data
                self.head.next = self.head.next.next
                return value

        def travel(self):
            temp = self.head
            while temp.next != None:
                print('{} '.format(temp.next.data), end='')
                temp = temp.next
            print('\n')

---

### 性能分析

   * 入队和出队的时间复杂度均为 O(1)

---

### 特点

   1. 操作受限，队头出队，队尾进队
   2. 先进先出，后进后出
   







